"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-activity-calendar/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-activity-calendar/build/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar chroma = __webpack_require__(/*! chroma-js */ \"(ssr)/./node_modules/chroma-js/chroma.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/index.mjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar chroma__default = /*#__PURE__*/ _interopDefault(chroma);\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nconst NAMESPACE = \"react-activity-calendar\";\nconst LABEL_MARGIN = 8; // px\nconst DEFAULT_MONTH_LABELS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst DEFAULT_LABELS = {\n    months: DEFAULT_MONTH_LABELS,\n    weekdays: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    totalCount: \"{{count}} activities in {{year}}\",\n    legend: {\n        less: \"Less\",\n        more: \"More\"\n    }\n};\nfunction useColorScheme() {\n    const [colorScheme, setColorScheme] = React.useState(\"light\");\n    const onChange = (event)=>setColorScheme(event.matches ? \"dark\" : \"light\");\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        setColorScheme(mediaQuery.matches ? \"dark\" : \"light\");\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return colorScheme;\n}\nconst query = \"(prefers-reduced-motion: reduce)\";\nfunction usePrefersReducedMotion() {\n    const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(true);\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(query);\n        setPrefersReducedMotion(mediaQuery.matches);\n        const onChange = (event)=>{\n            setPrefersReducedMotion(event.matches);\n        };\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return prefersReducedMotion;\n}\nfunction styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n    if (!css || typeof document === \"undefined\") {\n        return;\n    }\n    var head = document.head || document.getElementsByTagName(\"head\")[0];\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    if (insertAt === \"top\") {\n        if (head.firstChild) {\n            head.insertBefore(style, head.firstChild);\n        } else {\n            head.appendChild(style);\n        }\n    } else {\n        head.appendChild(style);\n    }\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n}\nvar css_248z = \".styles-module_container__GBNxC {\\n  width: max-content; /* Calendar should not grow */\\n  max-width: 100%; /* Do not remove - flexbox parents */\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.styles-module_container__GBNxC rect {\\n  stroke: rgba(0, 0, 0, 0.08);\\n  stroke-width: 1px;\\n  shape-rendering: geometricPrecision;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .styles-module_container__GBNxC rect {\\n    stroke: rgba(255, 255, 255, 0.04);\\n  }\\n}\\n\\n.styles-module_scrollContainer__-bJC8 {\\n  max-width: 100%;\\n  overflow-x: auto;\\n  overflow-y: hidden;\\n}\\n\\n.styles-module_calendar__sT1ND {\\n  display: block; /* SVGs are inline-block by default */\\n  overflow: visible; /* Weekday labels are rendered left of the container */\\n}\\n\\n.styles-module_calendar__sT1ND text {\\n  fill: currentColor;\\n}\\n\\n.styles-module_footer__ZQ-Bl {\\n  display: flex;\\n  flex-wrap: wrap;\\n  gap: 4px 16px;\\n  white-space: nowrap;\\n}\\n\\n.styles-module_legendColors__kFY2e {\\n  margin-left: auto;\\n  display: flex;\\n  align-items: center;\\n  gap: 3px;\\n}\\n\\n@keyframes styles-module_loadingAnimation__V0w3h {\\n  0% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n  50% {\\n    fill: var(--react-activity-calendar-loading-active);\\n  }\\n  100% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n}\\n\";\nvar styles = {\n    \"container\": \"styles-module_container__GBNxC\",\n    \"scrollContainer\": \"styles-module_scrollContainer__-bJC8\",\n    \"calendar\": \"styles-module_calendar__sT1ND\",\n    \"footer\": \"styles-module_footer__ZQ-Bl\",\n    \"legendColors\": \"styles-module_legendColors__kFY2e\",\n    \"loadingAnimation\": \"styles-module_loadingAnimation__V0w3h\"\n};\nstyleInject(css_248z);\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n    if (activities.length === 0) {\n        return [];\n    }\n    const normalizedActivities = fillHoles(activities);\n    // Determine the first date of the calendar. If the first date is not the\n    // set start weekday, the selected weekday one week earlier is used.\n    const firstDate = dateFns.parseISO(normalizedActivities[0].date);\n    const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n    // To correctly group activities by week, it is necessary to left-pad the list\n    // because the first date might not be set start weekday.\n    const paddedActivities = [\n        ...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined),\n        ...normalizedActivities\n    ];\n    const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n    // Finally, group activities by week\n    return Array(numberOfWeeks).fill(undefined).map((_, weekIndex)=>paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */ function fillHoles(activities) {\n    const dateMap = {};\n    for (const activity of activities){\n        dateMap[activity.date] = activity;\n    }\n    return dateFns.eachDayOfInterval({\n        start: dateFns.parseISO(activities[0].date),\n        end: dateFns.parseISO(activities[activities.length - 1].date)\n    }).map((day)=>{\n        const date = dateFns.formatISO(day, {\n            representation: \"date\"\n        });\n        if (dateMap[date]) {\n            return dateMap[date];\n        }\n        return {\n            date,\n            count: 0,\n            level: 0\n        };\n    });\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n    return weeks.reduce((labels, week, weekIndex)=>{\n        const firstActivity = week.find((activity)=>activity !== undefined);\n        if (!firstActivity) {\n            throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty: [${week}].`);\n        }\n        const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n        const prevLabel = labels[labels.length - 1];\n        if (weekIndex === 0 || prevLabel.label !== month) {\n            return [\n                ...labels,\n                {\n                    weekIndex,\n                    label: month\n                }\n            ];\n        }\n        return labels;\n    }, []).filter(({ weekIndex }, index, labels)=>{\n        // Labels should only be shown if there is \"enough\" space (data).\n        // This is a naive implementation that does not take the block size,\n        // font size etc. into account.\n        const minWeeks = 3;\n        // Skip the first month label if there is not enough space to the next one.\n        if (index === 0) {\n            return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n        }\n        // Skip the last month label the there is not enough data in that month to\n        // avoid overflowing the calendar on the right.\n        if (index === labels.length - 1) {\n            return weeks.slice(weekIndex).length >= minWeeks;\n        }\n        return true;\n    });\n}\nfunction getClassName(name, styles) {\n    if (styles) {\n        return `${NAMESPACE}__${name} ${styles}`;\n    }\n    return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n    const year = new Date().getFullYear();\n    const days = dateFns.eachDayOfInterval({\n        start: new Date(year, 0, 1),\n        end: new Date(year, 11, 31)\n    });\n    return days.map((date)=>({\n            date: dateFns.formatISO(date, {\n                representation: \"date\"\n            }),\n            count: 0,\n            level: 0\n        }));\n}\nfunction maxWeekdayLabelLength(firstWeek, weekStart, labels, fontSize) {\n    return firstWeek.reduce((maxLength, _, index)=>{\n        if (index % 2 !== 0) {\n            const dayIndex = (index + weekStart) % 7;\n            const curLength = Math.ceil(calcTextDimensions(labels[dayIndex], fontSize).width);\n            return Math.max(maxLength, curLength);\n        }\n        return maxLength;\n    }, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n    if (typeof document === \"undefined\" || \"undefined\" === \"undefined\") {\n        throw new Error(\"calcTextDimensions() requires browser APIs\");\n    }\n    if (fontSize < 1) {\n        throw new RangeError(\"fontSize must be positive\");\n    }\n    if (text.length === 0) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    const namespace = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(namespace, \"svg\");\n    svg.style.position = \"absolute\";\n    svg.style.visibility = \"hidden\";\n    svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n    svg.style.fontSize = `${fontSize}px`;\n    const textNode = document.createElementNS(namespace, \"text\");\n    textNode.textContent = text;\n    svg.appendChild(textNode);\n    document.body.appendChild(svg);\n    const boundingBox = textNode.getBBox();\n    document.body.removeChild(svg);\n    return {\n        width: boundingBox.width,\n        height: boundingBox.height\n    };\n}\nfunction createTheme(input, size = 5) {\n    const defaultTheme = createDefaultTheme(size);\n    if (input) {\n        validateTheme(input, size);\n        input.light = input.light ?? defaultTheme.light;\n        input.dark = input.dark ?? defaultTheme.dark;\n        return {\n            light: isColorScale(input.light, size) ? input.light : createColorScale(input.light, size),\n            dark: isColorScale(input.dark, size) ? input.dark : createColorScale(input.dark, size)\n        };\n    }\n    return defaultTheme;\n}\nfunction createDefaultTheme(size) {\n    return {\n        light: createColorScale([\n            \"hsl(0, 0%, 92%)\",\n            \"hsl(0, 0%, 26%)\"\n        ], size),\n        dark: createColorScale([\n            \"hsl(0, 0%, 20%)\",\n            \"hsl(0, 0%, 92%)\"\n        ], size)\n    };\n}\nfunction validateTheme(input, size) {\n    if (typeof input !== \"object\" || input.light === undefined && input.dark === undefined) {\n        throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${size} colors respectively.`);\n    }\n    if (input.light) {\n        const { length } = input.light;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.light must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n    if (input.dark) {\n        const { length } = input.dark;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.dark must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n}\nfunction isColorScale(colors, size) {\n    const invalidColor = colors.find((color)=>!chroma__default.default.valid(color));\n    if (invalidColor) {\n        throw new Error(`Invalid color \"${invalidColor}\" passed. All CSS color formats are accepted.`);\n    }\n    return colors.length === size;\n}\nfunction createColorScale(colors, size) {\n    return chroma__default.default.scale(colors).mode(\"lch\").colors(size);\n}\nconst ActivityCalendar = ({ data, blockMargin = 4, blockRadius = 2, blockSize = 12, colorScheme = undefined, eventHandlers = {}, fontSize = 14, hideColorLegend = false, hideMonthLabels = false, hideTotalCount = false, labels: labelsProp = undefined, maxLevel = 4, loading = false, renderBlock = undefined, showWeekdayLabels = false, style: styleProp = {}, theme: themeProp = undefined, totalCount: totalCountProp = undefined, weekStart = 0 // Sunday\n })=>{\n    maxLevel = Math.max(1, maxLevel);\n    const theme = createTheme(themeProp, maxLevel + 1);\n    const systemColorScheme = useColorScheme();\n    const colorScale = theme[colorScheme ?? systemColorScheme];\n    const useAnimation = !usePrefersReducedMotion();\n    if (loading) {\n        data = generateEmptyData();\n    }\n    if (data.length === 0) {\n        return null;\n    }\n    const year = dateFns.getYear(dateFns.parseISO(data[0]?.date));\n    const weeks = groupByWeeks(data, weekStart);\n    const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n    const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n    const weekdayLabelOffset = showWeekdayLabels ? maxWeekdayLabelLength(weeks[0], weekStart, labels.weekdays, fontSize) + LABEL_MARGIN : undefined;\n    function getDimensions() {\n        return {\n            width: weeks.length * (blockSize + blockMargin) - blockMargin,\n            height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n        };\n    }\n    function getEventHandlers(activity) {\n        return Object.keys(eventHandlers).reduce((handlers, key)=>({\n                ...handlers,\n                [key]: (event)=>eventHandlers[key]?.(event)(activity)\n            }), {});\n    }\n    function renderCalendar() {\n        return weeks.map((week, weekIndex)=>week.map((activity, dayIndex)=>{\n                if (!activity) {\n                    return null;\n                }\n                if (activity.level < 0 || activity.level > maxLevel) {\n                    throw new RangeError(`Provided activity level ${activity.level} for ${activity.date} is out of range. It must be between 0 and ${maxLevel}.`);\n                }\n                const style = loading && useAnimation ? {\n                    animation: `${styles.loadingAnimation} 1.75s ease-in-out infinite`,\n                    animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n                } : undefined;\n                const block = /*#__PURE__*/ React__default.default.createElement(\"rect\", _extends({}, getEventHandlers(activity), {\n                    x: 0,\n                    y: labelHeight + (blockSize + blockMargin) * dayIndex,\n                    width: blockSize,\n                    height: blockSize,\n                    rx: blockRadius,\n                    ry: blockRadius,\n                    fill: colorScale[activity.level],\n                    \"data-date\": activity.date,\n                    \"data-level\": activity.level,\n                    style: style\n                }));\n                return /*#__PURE__*/ React__default.default.createElement(React.Fragment, {\n                    key: activity.date\n                }, renderBlock ? renderBlock(block, activity) : block);\n            })).map((week, x)=>/*#__PURE__*/ React__default.default.createElement(\"g\", {\n                key: x,\n                transform: `translate(${(blockSize + blockMargin) * x}, 0)`\n            }, week));\n    }\n    function renderFooter() {\n        if (hideTotalCount && hideColorLegend) {\n            return null;\n        }\n        const totalCount = typeof totalCountProp === \"number\" ? totalCountProp : data.reduce((sum, activity)=>sum + activity.count, 0);\n        return /*#__PURE__*/ React__default.default.createElement(\"footer\", {\n            className: getClassName(\"footer\", styles.footer),\n            style: {\n                marginLeft: weekdayLabelOffset\n            }\n        }, loading && /*#__PURE__*/ React__default.default.createElement(\"div\", null, \"\\xa0\"), !loading && !hideTotalCount && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"count\")\n        }, labels.totalCount ? labels.totalCount.replace(\"{{count}}\", String(totalCount)).replace(\"{{year}}\", String(year)) : `${totalCount} activities in ${year}`), !loading && !hideColorLegend && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"legend-colors\", styles.legendColors)\n        }, /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginRight: \"0.4em\"\n            }\n        }, labels?.legend?.less ?? \"Less\"), Array(maxLevel + 1).fill(undefined).map((_, level)=>/*#__PURE__*/ React__default.default.createElement(\"svg\", {\n                width: blockSize,\n                height: blockSize,\n                key: level\n            }, /*#__PURE__*/ React__default.default.createElement(\"rect\", {\n                width: blockSize,\n                height: blockSize,\n                fill: colorScale[level],\n                rx: blockRadius,\n                ry: blockRadius\n            }))), /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginLeft: \"0.4em\"\n            }\n        }, labels?.legend?.more ?? \"More\")));\n    }\n    function renderLabels() {\n        if (!showWeekdayLabels && hideMonthLabels) {\n            return null;\n        }\n        return /*#__PURE__*/ React__default.default.createElement(React__default.default.Fragment, null, showWeekdayLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-weekday\")\n        }, weeks[0].map((_, index)=>{\n            if (index % 2 === 0) {\n                return null;\n            }\n            const dayIndex = (index + weekStart) % 7;\n            return /*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: -LABEL_MARGIN,\n                y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n                dominantBaseline: \"middle\",\n                textAnchor: \"end\",\n                key: index\n            }, labels.weekdays[dayIndex]);\n        })), !hideMonthLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-month\")\n        }, getMonthLabels(weeks, labels.months).map(({ label, weekIndex })=>/*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: (blockSize + blockMargin) * weekIndex,\n                dominantBaseline: \"hanging\",\n                key: weekIndex\n            }, label))));\n    }\n    const { width, height } = getDimensions();\n    const containerStyles = {\n        fontSize,\n        ...useAnimation && {\n            [`--${NAMESPACE}-loading`]: colorScale[0],\n            [`--${NAMESPACE}-loading-active`]: colorScheme === \"light\" ? chroma__default.default(colorScale[0]).darken(0.3).hex() : chroma__default.default(colorScale[0]).brighten(0.25).hex()\n        }\n    };\n    return /*#__PURE__*/ React__default.default.createElement(\"article\", {\n        className: `${NAMESPACE} ${styles.container}`,\n        style: {\n            ...styleProp,\n            ...containerStyles\n        }\n    }, /*#__PURE__*/ React__default.default.createElement(\"div\", {\n        className: getClassName(\"scroll-container\", styles.scrollContainer)\n    }, /*#__PURE__*/ React__default.default.createElement(\"svg\", {\n        width: width,\n        height: height,\n        viewBox: `0 0 ${width} ${height}`,\n        className: getClassName(\"calendar\", styles.calendar),\n        style: {\n            marginLeft: weekdayLabelOffset\n        }\n    }, !loading && renderLabels(), renderCalendar())), renderFooter());\n};\nconst Skeleton = (props)=>/*#__PURE__*/ React__default.default.createElement(ActivityCalendar, _extends({\n        data: []\n    }, props));\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLFlBQVk7QUFDbEIsTUFBTUMsZUFBZSxHQUFFO0FBRXZCLE1BQU1DLHVCQUF1QjtJQUNsQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLE1BQU1DLGlCQUFpQjtJQUM1QkMsUUFBUUY7SUFDUkcsVUFBVTtRQUFDO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztRQUFPO0tBQU07SUFDM0RDLFlBQVk7SUFDWkMsUUFBUTtRQUNOQyxNQUFNO1FBQ05DLE1BQU07SUFDUjtBQUNGO0FDdEJPLFNBQVNDO0lBQ2QsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdDLE1BQUFBLFFBQVEsQ0FBbUI7SUFFakUsTUFBTUMsV0FBWUMsQ0FBQUEsUUFBK0JILGVBQWVHLE1BQU1DLE9BQU8sR0FBRyxTQUFTO0lBRXpGQyxNQUFBQSxTQUFTLENBQUM7UUFDUixNQUFNQyxhQUFhQyxPQUFPQyxVQUFVLENBQUM7UUFDckNSLGVBQWVNLFdBQVdGLE9BQU8sR0FBRyxTQUFTO1FBRTdDRSxXQUFXRyxnQkFBZ0IsQ0FBQyxVQUFVUDtRQUV0QyxPQUFPO1lBQ0xJLFdBQVdJLG1CQUFtQixDQUFDLFVBQVVSOztPQUUxQyxFQUFFO0lBRUwsT0FBT0g7QUFDVDtBQ2pCQSxNQUFNWSxRQUFRO0FBRVAsU0FBU0M7SUFDZCxNQUFNLENBQUNDLHNCQUFzQkMsd0JBQXdCLEdBQUdiLE1BQUFBLFFBQVEsQ0FBQztJQUVqRUksTUFBQUEsU0FBUyxDQUFDO1FBQ1IsTUFBTUMsYUFBYUMsT0FBT0MsVUFBVSxDQUFDRztRQUNyQ0csd0JBQXdCUixXQUFXRixPQUFPO1FBRTFDLE1BQU1GLFdBQVlDLENBQUFBO1lBQ2hCVyx3QkFBd0JYLE1BQU1D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QUU7WUFDekMsQ0FBRSxLQUFJbkssVUFBVSxnQkFBZ0IsR0FDOUJXLGdCQUFnQixVQUNaaUksZ0JBQUFBLE9BQU0sQ0FBQ3VCLFVBQVUsQ0FBQyxFQUFFLEVBQUVzQyxNQUFNLENBQUMsS0FBS0MsR0FBRyxLQUNyQzlELGdCQUFBQSxPQUFNLENBQUN1QixVQUFVLENBQUMsRUFBRSxFQUFFd0MsUUFBUSxDQUFDLE1BQU1ELEdBQUc7U0FDL0M7O0lBR0gscUJBQ0V0QixlQUFBQSxPQUFBLENBQUFqSixhQUFBO1FBQ0UySixXQUFZLENBQUU5TCxFQUFBQSxVQUFVLEdBQUdnRyxPQUFPNEcsU0FBVSxDQUFFO1FBQzlDMUssT0FBTztZQUFFLEdBQUc0SCxTQUFTO1lBQUUsR0FBRzBDLGVBQUFBO1FBQWdCO09BRTFDcEIsV0FBQUEsR0FBQUEsZUFBQUEsT0FBQSxDQUFBakosYUFBQTtRQUFLMkosV0FBV2hHLGFBQWEsb0JBQW9CRSxPQUFPNkcsZUFBZTtPQUNyRXpCLFdBQUFBLEdBQUFBLGVBQUFBLE9BQUEsQ0FBQWpKLGFBQUE7UUFDRTBFLE9BQU9BO1FBQ1BJLFFBQVFBO1FBQ1I2RixTQUFVLE9BQU1qRyxNQUFNLEdBQUdJLE9BQVM7UUFDbEM2RSxXQUFXaEcsYUFBYSxZQUFZRSxPQUFPK0csUUFBUTtRQUNuRDdLLE9BQU87WUFBRThKLFlBQVl2QjtRQUFtQjtJQUFFLEdBRXpDLENBQUNkLFdBQVcwQyxnQkFDWnRCLG9CQUdKYTtBQUdQO0FBRU8sTUFBTW9CLFdBQW1EQyxDQUFBQSxRQUFLLGNBQ25FN0IsZUFBQUEsT0FBQSxDQUFBakosYUFBQSxDQUFDNkcsa0JBQWdCcUMsU0FBQTtRQUFDcEMsTUFBTTtJQUFHLEdBQUtnRSIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1Yl9jb250cmlidXRpb25fbGlmZS8uLi9zcmMvY29uc3RhbnRzLnRzP2IxM2UiLCJ3ZWJwYWNrOi8vZ2l0aHViX2NvbnRyaWJ1dGlvbl9saWZlLy4uL3NyYy9ob29rcy91c2VDb2xvclNjaGVtZS50cz83OWM3Iiwid2VicGFjazovL2dpdGh1Yl9jb250cmlidXRpb25fbGlmZS8uLi9zcmMvaG9va3MvdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24udHM/Nzk5YyIsIndlYnBhY2s6Ly9naXRodWJfY29udHJpYnV0aW9uX2xpZmUvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0eWxlLWluamVjdEAwLjMuMC9ub2RlX21vZHVsZXMvc3R5bGUtaW5qZWN0L2Rpc3Qvc3R5bGUtaW5qZWN0LmVzLmpzPzYzMGUiLCJ3ZWJwYWNrOi8vZ2l0aHViX2NvbnRyaWJ1dGlvbl9saWZlLy4uL3NyYy91dGlscy9jYWxlbmRhci50cz9hYmU3Iiwid2VicGFjazovL2dpdGh1Yl9jb250cmlidXRpb25fbGlmZS8uLi9zcmMvdXRpbHMvdGhlbWUudHM/NzZkNiIsIndlYnBhY2s6Ly9naXRodWJfY29udHJpYnV0aW9uX2xpZmUvLi4vc3JjL2NvbXBvbmVudC9BY3Rpdml0eUNhbGVuZGFyLnRzeD80YjgzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBOQU1FU1BBQ0UgPSAncmVhY3QtYWN0aXZpdHktY2FsZW5kYXInO1xuZXhwb3J0IGNvbnN0IExBQkVMX01BUkdJTiA9IDg7IC8vIHB4XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PTlRIX0xBQkVMUyA9IFtcbiAgJ0phbicsXG4gICdGZWInLFxuICAnTWFyJyxcbiAgJ0FwcicsXG4gICdNYXknLFxuICAnSnVuJyxcbiAgJ0p1bCcsXG4gICdBdWcnLFxuICAnU2VwJyxcbiAgJ09jdCcsXG4gICdOb3YnLFxuICAnRGVjJyxcbl07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xBQkVMUyA9IHtcbiAgbW9udGhzOiBERUZBVUxUX01PTlRIX0xBQkVMUyxcbiAgd2Vla2RheXM6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHRvdGFsQ291bnQ6ICd7e2NvdW50fX0gYWN0aXZpdGllcyBpbiB7e3llYXJ9fScsXG4gIGxlZ2VuZDoge1xuICAgIGxlc3M6ICdMZXNzJyxcbiAgICBtb3JlOiAnTW9yZScsXG4gIH0sXG59O1xuIiwiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29sb3JTY2hlbWUoKSB7XG4gIGNvbnN0IFtjb2xvclNjaGVtZSwgc2V0Q29sb3JTY2hlbWVdID0gdXNlU3RhdGU8J2xpZ2h0JyB8ICdkYXJrJz4oJ2xpZ2h0Jyk7XG5cbiAgY29uc3Qgb25DaGFuZ2UgPSAoZXZlbnQ6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IHNldENvbG9yU2NoZW1lKGV2ZW50Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xuICAgIHNldENvbG9yU2NoZW1lKG1lZGlhUXVlcnkubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCcpO1xuXG4gICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBjb2xvclNjaGVtZTtcbn1cbiIsIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgcXVlcnkgPSAnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSknO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gIGNvbnN0IFtwcmVmZXJzUmVkdWNlZE1vdGlvbiwgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb25dID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpO1xuICAgIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uKG1lZGlhUXVlcnkubWF0Y2hlcyk7XG5cbiAgICBjb25zdCBvbkNoYW5nZSA9IChldmVudDogTWVkaWFRdWVyeUxpc3RFdmVudCkgPT4ge1xuICAgICAgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24oZXZlbnQubWF0Y2hlcyk7XG4gICAgfTtcblxuICAgIG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lZGlhUXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gcHJlZmVyc1JlZHVjZWRNb3Rpb247XG59XG4iLCJmdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcblxuICBpZiAoIWNzcyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybjsgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlSW5qZWN0O1xuIiwiaW1wb3J0IHR5cGUgeyBEYXkgYXMgV2Vla0RheSB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7XG4gIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyxcbiAgZWFjaERheU9mSW50ZXJ2YWwsXG4gIGVuZE9mWWVhcixcbiAgZm9ybWF0SVNPLFxuICBnZXREYXksXG4gIGdldE1vbnRoLFxuICBuZXh0RGF5LFxuICBwYXJzZUlTTyxcbiAgc3RhcnRPZlllYXIsXG4gIHN1YldlZWtzLFxufSBmcm9tICdkYXRlLWZucyc7XG5cbmltcG9ydCB7IERFRkFVTFRfTU9OVEhfTEFCRUxTLCBOQU1FU1BBQ0UgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQWN0aXZpdHksIFdlZWsgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBNb250aExhYmVsIHtcbiAgd2Vla0luZGV4OiBudW1iZXI7XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5V2Vla3MoXG4gIGFjdGl2aXRpZXM6IEFycmF5PEFjdGl2aXR5PixcbiAgd2Vla1N0YXJ0OiBXZWVrRGF5ID0gMCwgLy8gMCA9IFN1bmRheVxuKTogQXJyYXk8V2Vlaz4ge1xuICBpZiAoYWN0aXZpdGllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkQWN0aXZpdGllcyA9IGZpbGxIb2xlcyhhY3Rpdml0aWVzKTtcblxuICAvLyBEZXRlcm1pbmUgdGhlIGZpcnN0IGRhdGUgb2YgdGhlIGNhbGVuZGFyLiBJZiB0aGUgZmlyc3QgZGF0ZSBpcyBub3QgdGhlXG4gIC8vIHNldCBzdGFydCB3ZWVrZGF5LCB0aGUgc2VsZWN0ZWQgd2Vla2RheSBvbmUgd2VlayBlYXJsaWVyIGlzIHVzZWQuXG4gIGNvbnN0IGZpcnN0RGF0ZSA9IHBhcnNlSVNPKG5vcm1hbGl6ZWRBY3Rpdml0aWVzWzBdLmRhdGUpO1xuICBjb25zdCBmaXJzdENhbGVuZGFyRGF0ZSA9XG4gICAgZ2V0RGF5KGZpcnN0RGF0ZSkgPT09IHdlZWtTdGFydCA/IGZpcnN0RGF0ZSA6IHN1YldlZWtzKG5leHREYXkoZmlyc3REYXRlLCB3ZWVrU3RhcnQpLCAxKTtcblxuICAvLyBUbyBjb3JyZWN0bHkgZ3JvdXAgYWN0aXZpdGllcyBieSB3ZWVrLCBpdCBpcyBuZWNlc3NhcnkgdG8gbGVmdC1wYWQgdGhlIGxpc3RcbiAgLy8gYmVjYXVzZSB0aGUgZmlyc3QgZGF0ZSBtaWdodCBub3QgYmUgc2V0IHN0YXJ0IHdlZWtkYXkuXG4gIGNvbnN0IHBhZGRlZEFjdGl2aXRpZXMgPSBbXG4gICAgLi4uQXJyYXkoZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGZpcnN0RGF0ZSwgZmlyc3RDYWxlbmRhckRhdGUpKS5maWxsKHVuZGVmaW5lZCksXG4gICAgLi4ubm9ybWFsaXplZEFjdGl2aXRpZXMsXG4gIF07XG5cbiAgY29uc3QgbnVtYmVyT2ZXZWVrcyA9IE1hdGguY2VpbChwYWRkZWRBY3Rpdml0aWVzLmxlbmd0aCAvIDcpO1xuXG4gIC8vIEZpbmFsbHksIGdyb3VwIGFjdGl2aXRpZXMgYnkgd2Vla1xuICByZXR1cm4gQXJyYXkobnVtYmVyT2ZXZWVrcylcbiAgICAuZmlsbCh1bmRlZmluZWQpXG4gICAgLm1hcCgoXywgd2Vla0luZGV4KSA9PiBwYWRkZWRBY3Rpdml0aWVzLnNsaWNlKHdlZWtJbmRleCAqIDcsIHdlZWtJbmRleCAqIDcgKyA3KSk7XG59XG5cbi8qKlxuICogVGhlIGNhbGVuZGFyIGV4cGVjdHMgYSBjb250aW51b3VzIHNlcXVlbmNlIG9mIGRheXMsXG4gKiBzbyBmaWxsIGdhcHMgd2l0aCBlbXB0eSBhY3Rpdml0eSBkYXRhLlxuICovXG5mdW5jdGlvbiBmaWxsSG9sZXMoYWN0aXZpdGllczogQXJyYXk8QWN0aXZpdHk+KTogQXJyYXk8QWN0aXZpdHk+IHtcbiAgY29uc3QgZGF0ZU1hcDogUmVjb3JkPHN0cmluZywgQWN0aXZpdHk+ID0ge307XG4gIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgYWN0aXZpdGllcykge1xuICAgIGRhdGVNYXBbYWN0aXZpdHkuZGF0ZV0gPSBhY3Rpdml0eTtcbiAgfVxuXG4gIHJldHVybiBlYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IHBhcnNlSVNPKGFjdGl2aXRpZXNbMF0uZGF0ZSksXG4gICAgZW5kOiBwYXJzZUlTTyhhY3Rpdml0aWVzW2FjdGl2aXRpZXMubGVuZ3RoIC0gMV0uZGF0ZSksXG4gIH0pLm1hcChkYXkgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBmb3JtYXRJU08oZGF5LCB7IHJlcHJlc2VudGF0aW9uOiAnZGF0ZScgfSk7XG5cbiAgICBpZiAoZGF0ZU1hcFtkYXRlXSkge1xuICAgICAgcmV0dXJuIGRhdGVNYXBbZGF0ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGUsXG4gICAgICBjb3VudDogMCxcbiAgICAgIGxldmVsOiAwLFxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9udGhMYWJlbHMoXG4gIHdlZWtzOiBBcnJheTxXZWVrPixcbiAgbW9udGhOYW1lczogQXJyYXk8c3RyaW5nPiA9IERFRkFVTFRfTU9OVEhfTEFCRUxTLFxuKTogQXJyYXk8TW9udGhMYWJlbD4ge1xuICByZXR1cm4gd2Vla3NcbiAgICAucmVkdWNlPEFycmF5PE1vbnRoTGFiZWw+PigobGFiZWxzLCB3ZWVrLCB3ZWVrSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0QWN0aXZpdHkgPSB3ZWVrLmZpbmQoYWN0aXZpdHkgPT4gYWN0aXZpdHkgIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgIGlmICghZmlyc3RBY3Rpdml0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3I6IFdlZWsgJHt3ZWVrSW5kZXggKyAxfSBpcyBlbXB0eTogWyR7d2Vla31dLmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb250aCA9IG1vbnRoTmFtZXNbZ2V0TW9udGgocGFyc2VJU08oZmlyc3RBY3Rpdml0eS5kYXRlKSldO1xuICAgICAgY29uc3QgcHJldkxhYmVsID0gbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHdlZWtJbmRleCA9PT0gMCB8fCBwcmV2TGFiZWwubGFiZWwgIT09IG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBbLi4ubGFiZWxzLCB7IHdlZWtJbmRleCwgbGFiZWw6IG1vbnRoIH1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sIFtdKVxuICAgIC5maWx0ZXIoKHsgd2Vla0luZGV4IH0sIGluZGV4LCBsYWJlbHMpID0+IHtcbiAgICAgIC8vIExhYmVscyBzaG91bGQgb25seSBiZSBzaG93biBpZiB0aGVyZSBpcyBcImVub3VnaFwiIHNwYWNlIChkYXRhKS5cbiAgICAgIC8vIFRoaXMgaXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXMgbm90IHRha2UgdGhlIGJsb2NrIHNpemUsXG4gICAgICAvLyBmb250IHNpemUgZXRjLiBpbnRvIGFjY291bnQuXG4gICAgICBjb25zdCBtaW5XZWVrcyA9IDM7XG5cbiAgICAgIC8vIFNraXAgdGhlIGZpcnN0IG1vbnRoIGxhYmVsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgdG8gdGhlIG5leHQgb25lLlxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbMV0gJiYgbGFiZWxzWzFdLndlZWtJbmRleCAtIHdlZWtJbmRleCA+PSBtaW5XZWVrcztcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCB0aGUgbGFzdCBtb250aCBsYWJlbCB0aGUgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIGluIHRoYXQgbW9udGggdG9cbiAgICAgIC8vIGF2b2lkIG92ZXJmbG93aW5nIHRoZSBjYWxlbmRhciBvbiB0aGUgcmlnaHQuXG4gICAgICBpZiAoaW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiB3ZWVrcy5zbGljZSh3ZWVrSW5kZXgpLmxlbmd0aCA+PSBtaW5XZWVrcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWUobmFtZTogc3RyaW5nLCBzdHlsZXM/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoc3R5bGVzKSB7XG4gICAgcmV0dXJuIGAke05BTUVTUEFDRX1fXyR7bmFtZX0gJHtzdHlsZXN9YDtcbiAgfVxuXG4gIHJldHVybiBgJHtOQU1FU1BBQ0V9X18ke25hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRW1wdHlEYXRhKCk6IEFycmF5PEFjdGl2aXR5PiB7XG4gIGNvbnN0IHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IGRheXMgPSBlYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHllYXIsIDAsIDEpLFxuICAgIGVuZDogbmV3IERhdGUoeWVhciwgMTEsIDMxKSxcbiAgfSk7XG5cbiAgcmV0dXJuIGRheXMubWFwKGRhdGUgPT4gKHtcbiAgICBkYXRlOiBmb3JtYXRJU08oZGF0ZSwgeyByZXByZXNlbnRhdGlvbjogJ2RhdGUnIH0pLFxuICAgIGNvdW50OiAwLFxuICAgIGxldmVsOiAwLFxuICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRlc3REYXRhKGFyZ3M6IHtcbiAgaW50ZXJ2YWw/OiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfTtcbiAgbWF4TGV2ZWw/OiBudW1iZXI7XG59KTogQXJyYXk8QWN0aXZpdHk+IHtcbiAgY29uc3QgbWF4Q291bnQgPSAyMDtcbiAgY29uc3QgbWF4TGV2ZWwgPSBhcmdzLm1heExldmVsID8gTWF0aC5tYXgoMSwgYXJncy5tYXhMZXZlbCkgOiA0O1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIGNvbnN0IGRheXMgPSBlYWNoRGF5T2ZJbnRlcnZhbChcbiAgICBhcmdzLmludGVydmFsID8/IHtcbiAgICAgIHN0YXJ0OiBzdGFydE9mWWVhcihub3cpLFxuICAgICAgZW5kOiBlbmRPZlllYXIobm93KSxcbiAgICB9LFxuICApO1xuXG4gIHJldHVybiBkYXlzLm1hcChkYXRlID0+IHtcbiAgICAvLyBUaGUgcmFuZG9tIGFjdGl2aXR5IGNvdW50IGlzIHNoaWZ0ZWQgYnkgdXAgdG8gODAlIHRvd2FyZHMgemVyby5cbiAgICBjb25zdCBjID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogbWF4Q291bnQgLSBNYXRoLnJhbmRvbSgpICogKDAuOCAqIG1heENvdW50KSk7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1heCgwLCBjKTtcbiAgICBjb25zdCBsZXZlbCA9IE1hdGguY2VpbCgoY291bnQgLyBtYXhDb3VudCkgKiBtYXhMZXZlbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZTogZm9ybWF0SVNPKGRhdGUsIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KSxcbiAgICAgIGNvdW50LFxuICAgICAgbGV2ZWwsXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXhXZWVrZGF5TGFiZWxMZW5ndGgoXG4gIGZpcnN0V2VlazogV2VlayxcbiAgd2Vla1N0YXJ0OiBudW1iZXIsXG4gIGxhYmVsczogc3RyaW5nW10sXG4gIGZvbnRTaXplOiBudW1iZXIsXG4pOiBudW1iZXIge1xuICByZXR1cm4gZmlyc3RXZWVrLnJlZHVjZSgobWF4TGVuZ3RoLCBfLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCAlIDIgIT09IDApIHtcbiAgICAgIGNvbnN0IGRheUluZGV4ID0gKGluZGV4ICsgd2Vla1N0YXJ0KSAlIDc7XG4gICAgICBjb25zdCBjdXJMZW5ndGggPSBNYXRoLmNlaWwoY2FsY1RleHREaW1lbnNpb25zKGxhYmVsc1tkYXlJbmRleF0sIGZvbnRTaXplKS53aWR0aCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1heChtYXhMZW5ndGgsIGN1ckxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heExlbmd0aDtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGNUZXh0RGltZW5zaW9ucyh0ZXh0OiBzdHJpbmcsIGZvbnRTaXplOiBudW1iZXIpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGNUZXh0RGltZW5zaW9ucygpIHJlcXVpcmVzIGJyb3dzZXIgQVBJcycpO1xuICB9XG5cbiAgaWYgKGZvbnRTaXplIDwgMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmb250U2l6ZSBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cblxuICBjb25zdCBuYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnc3ZnJyk7XG5cbiAgc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgc3ZnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgc3ZnLnN0eWxlLmZvbnRGYW1pbHkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5mb250RmFtaWx5O1xuICBzdmcuc3R5bGUuZm9udFNpemUgPSBgJHtmb250U2l6ZX1weGA7XG5cbiAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAndGV4dCcpO1xuICB0ZXh0Tm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG5cbiAgc3ZnLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICBjb25zdCBib3VuZGluZ0JveCA9IHRleHROb2RlLmdldEJCb3goKTtcblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgcmV0dXJuIHsgd2lkdGg6IGJvdW5kaW5nQm94LndpZHRoLCBoZWlnaHQ6IGJvdW5kaW5nQm94LmhlaWdodCB9O1xufVxuIiwiaW1wb3J0IGNocm9tYSBmcm9tICdjaHJvbWEtanMnO1xuXG5pbXBvcnQgeyBDb2xvciwgQ29sb3JTY2FsZSwgVGhlbWUsIFRoZW1lSW5wdXQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaGVtZShpbnB1dD86IFRoZW1lSW5wdXQsIHNpemU6IG51bWJlciA9IDUpOiBUaGVtZSB7XG4gIGNvbnN0IGRlZmF1bHRUaGVtZSA9IGNyZWF0ZURlZmF1bHRUaGVtZShzaXplKTtcblxuICBpZiAoaW5wdXQpIHtcbiAgICB2YWxpZGF0ZVRoZW1lKGlucHV0LCBzaXplKTtcblxuICAgIGlucHV0LmxpZ2h0ID0gaW5wdXQubGlnaHQgPz8gZGVmYXVsdFRoZW1lLmxpZ2h0O1xuICAgIGlucHV0LmRhcmsgPSBpbnB1dC5kYXJrID8/IGRlZmF1bHRUaGVtZS5kYXJrO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpZ2h0OiBpc0NvbG9yU2NhbGUoaW5wdXQubGlnaHQsIHNpemUpID8gaW5wdXQubGlnaHQgOiBjcmVhdGVDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzaXplKSxcbiAgICAgIGRhcms6IGlzQ29sb3JTY2FsZShpbnB1dC5kYXJrLCBzaXplKSA/IGlucHV0LmRhcmsgOiBjcmVhdGVDb2xvclNjYWxlKGlucHV0LmRhcmssIHNpemUpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFRoZW1lO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0VGhlbWUoc2l6ZTogbnVtYmVyKTogVGhlbWUge1xuICByZXR1cm4ge1xuICAgIGxpZ2h0OiBjcmVhdGVDb2xvclNjYWxlKFsnaHNsKDAsIDAlLCA5MiUpJywgJ2hzbCgwLCAwJSwgMjYlKSddLCBzaXplKSxcbiAgICBkYXJrOiBjcmVhdGVDb2xvclNjYWxlKFsnaHNsKDAsIDAlLCAyMCUpJywgJ2hzbCgwLCAwJSwgOTIlKSddLCBzaXplKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaGVtZShpbnB1dDogVGhlbWVJbnB1dCwgc2l6ZTogbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IChpbnB1dC5saWdodCA9PT0gdW5kZWZpbmVkICYmIGlucHV0LmRhcmsgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIHRoZW1lIG9iamVjdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWVsZHMgXCJsaWdodFwiIGFuZCBcImRhcmtcIiB3aXRoIGV4YWN0bHkgMiBvciAke3NpemV9IGNvbG9ycyByZXNwZWN0aXZlbHkuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKGlucHV0LmxpZ2h0KSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0LmxpZ2h0O1xuICAgIGlmIChsZW5ndGggIT09IDIgJiYgbGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0aGVtZS5saWdodCBtdXN0IGNvbnRhaW4gZXhhY3RseSAyIG9yICR7c2l6ZX0gY29sb3JzLCAke2xlbmd0aCBhcyBudW1iZXJ9IHBhc3NlZC5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXQuZGFyaykge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBpbnB1dC5kYXJrO1xuICAgIGlmIChsZW5ndGggIT09IDIgJiYgbGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0aGVtZS5kYXJrIG11c3QgY29udGFpbiBleGFjdGx5IDIgb3IgJHtzaXplfSBjb2xvcnMsICR7bGVuZ3RoIGFzIG51bWJlcn0gcGFzc2VkLmAsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbG9yU2NhbGUoY29sb3JzOiBBcnJheTx1bmtub3duPiwgc2l6ZTogbnVtYmVyKTogY29sb3JzIGlzIENvbG9yU2NhbGUge1xuICBjb25zdCBpbnZhbGlkQ29sb3IgPSBjb2xvcnMuZmluZChjb2xvciA9PiAhY2hyb21hLnZhbGlkKGNvbG9yKSk7XG5cbiAgaWYgKGludmFsaWRDb2xvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciBcIiR7aW52YWxpZENvbG9yfVwiIHBhc3NlZC4gQWxsIENTUyBjb2xvciBmb3JtYXRzIGFyZSBhY2NlcHRlZC5gKTtcbiAgfVxuXG4gIHJldHVybiBjb2xvcnMubGVuZ3RoID09PSBzaXplO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb2xvclNjYWxlKGNvbG9yczogW2Zyb206IENvbG9yLCB0bzogQ29sb3JdLCBzaXplOiBudW1iZXIpOiBDb2xvclNjYWxlIHtcbiAgcmV0dXJuIGNocm9tYS5zY2FsZShjb2xvcnMpLm1vZGUoJ2xjaCcpLmNvbG9ycyhzaXplKTtcbn1cbiIsImltcG9ydCBjaHJvbWEgZnJvbSAnY2hyb21hLWpzJztcbmltcG9ydCB0eXBlIHsgRGF5IGFzIFdlZWtEYXkgfSBmcm9tICdkYXRlLWZucyc7XG5pbXBvcnQgeyBnZXRZZWFyLCBwYXJzZUlTTyB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzLCBGcmFnbWVudCwgRnVuY3Rpb25Db21wb25lbnQsIFJlYWN0RWxlbWVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgREVGQVVMVF9MQUJFTFMsIExBQkVMX01BUkdJTiwgTkFNRVNQQUNFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHVzZUNvbG9yU2NoZW1lIH0gZnJvbSAnLi4vaG9va3MvdXNlQ29sb3JTY2hlbWUnO1xuaW1wb3J0IHsgdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24gfSBmcm9tICcuLi9ob29rcy91c2VQcmVmZXJzUmVkdWNlZE1vdGlvbic7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4uL3N0eWxlcy9zdHlsZXMubW9kdWxlLmNzcyc7XG5pbXBvcnQge1xuICBBY3Rpdml0eSxcbiAgQmxvY2tFbGVtZW50LFxuICBFdmVudEhhbmRsZXJNYXAsXG4gIExhYmVscyxcbiAgUmVhY3RFdmVudCxcbiAgU1ZHUmVjdEV2ZW50SGFuZGxlcixcbiAgVGhlbWVJbnB1dCxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVFbXB0eURhdGEsXG4gIGdldENsYXNzTmFtZSxcbiAgZ2V0TW9udGhMYWJlbHMsXG4gIGdyb3VwQnlXZWVrcyxcbiAgbWF4V2Vla2RheUxhYmVsTGVuZ3RoLFxufSBmcm9tICcuLi91dGlscy9jYWxlbmRhcic7XG5pbXBvcnQgeyBjcmVhdGVUaGVtZSB9IGZyb20gJy4uL3V0aWxzL3RoZW1lJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIGNhbGVuZGFyIGVudHJpZXMuIEV2ZXJ5IGBBY3Rpdml0eWAgb2JqZWN0IHJlcXVpcmVzIGFuIElTTyA4NjAxXG4gICAqIGBkYXRlYCBzdHJpbmcgaW4gdGhlIGZvcm1hdCBgeXl5eS1NTS1kZGAsIGEgYGNvdW50YCBwcm9wZXJ0eSB3aXRoIHRoZVxuICAgKiBhbW91bnQgb2YgdHJhY2tlZCBkYXRhIGFuZCBhIGBsZXZlbGAgcHJvcGVydHkgaW4gdGhlIHJhbmdlIGAwLW1heExldmVsYFxuICAgKiB0byBzcGVjaWZ5IGFjdGl2aXR5IGludGVuc2l0eS4gVGhlIGBtYXhMZXZlbGAgcHJvcCBpcyA0IGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEZvciBtaXNzaW5nIGRhdGVzLCBubyBhY3Rpdml0eSBpcyBhc3N1bWVkLiBUaGlzIGFsbG93cyBjaG9vc2luZyB0aGUgc3RhcnRcbiAgICogYW5kIGVuZCBkYXRlIG9mIHRoZSBjYWxlbmRhciBhcmJpdHJhcmlseSBieSBwYXNzaW5nIGVtcHR5IGVudHJpZXMgYXMgdGhlXG4gICAqIGZpcnN0IGFuZCBsYXN0IGl0ZW0uXG4gICAqXG4gICAqIEV4YW1wbGUgb2JqZWN0OlxuICAgKlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBkYXRlOiBcIjIwMjEtMDItMjBcIixcbiAgICogICBjb3VudDogMTYsXG4gICAqICAgbGV2ZWw6IDNcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGRhdGE6IEFycmF5PEFjdGl2aXR5PjtcbiAgLyoqXG4gICAqIE1hcmdpbiBiZXR3ZWVuIGJsb2NrcyBpbiBwaXhlbHMuXG4gICAqL1xuICBibG9ja01hcmdpbj86IG51bWJlcjtcbiAgLyoqXG4gICAqIEJvcmRlciByYWRpdXMgb2YgYmxvY2tzIGluIHBpeGVscy5cbiAgICovXG4gIGJsb2NrUmFkaXVzPzogbnVtYmVyO1xuICAvKipcbiAgICogQmxvY2sgc2l6ZSBpbiBwaXhlbHMuXG4gICAqL1xuICBibG9ja1NpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBVc2UgYSBzcGVjaWZpYyBjb2xvciBzY2hlbWUgaW5zdGVhZCBvZiB0aGUgc3lzdGVtIG9uZS4gU3VwcG9ydGVkIHZhbHVlc1xuICAgKiBhcmUgYCdsaWdodCdgIGFuZCBgJ2RhcmsnYC5cbiAgICovXG4gIGNvbG9yU2NoZW1lPzogJ2xpZ2h0JyB8ICdkYXJrJztcbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXJzIHRvIHJlZ2lzdGVyIGZvciB0aGUgU1ZHIGA8cmVjdD5gIGVsZW1lbnRzIHRoYXQgYXJlIHVzZWQgdG9cbiAgICogcmVuZGVyIHRoZSBjYWxlbmRhciBkYXlzLiBIYW5kbGVyIHNpZ25hdHVyZTogYGV2ZW50ID0+IGFjdGl2aXR5ID0+IHZvaWRgXG4gICAqL1xuICBldmVudEhhbmRsZXJzPzogRXZlbnRIYW5kbGVyTWFwO1xuICAvKipcbiAgICogRm9udCBzaXplIGZvciB0ZXh0IGluIHBpeGVscy5cbiAgICovXG4gIGZvbnRTaXplPzogbnVtYmVyO1xuICAvKipcbiAgICogVG9nZ2xlIHRvIGhpZGUgY29sb3IgbGVnZW5kIGJlbG93IGNhbGVuZGFyLlxuICAgKi9cbiAgaGlkZUNvbG9yTGVnZW5kPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBoaWRlIG1vbnRoIGxhYmVscyBhYm92ZSBjYWxlbmRhci5cbiAgICovXG4gIGhpZGVNb250aExhYmVscz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gaGlkZSB0aGUgdG90YWwgY291bnQgYmVsb3cgY2FsZW5kYXIuXG4gICAqL1xuICBoaWRlVG90YWxDb3VudD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBMb2NhbGl6YXRpb24gc3RyaW5ncyBmb3IgYWxsIGNhbGVuZGFyIGxhYmVscy5cbiAgICpcbiAgICogYHRvdGFsQ291bnRgIHN1cHBvcnRzIHRoZSBwbGFjZWhvbGRlcnMgYHt7Y291bnR9fWAgYW5kIGB7e3llYXJ9fWAuXG4gICAqL1xuICBsYWJlbHM/OiBMYWJlbHM7XG4gIC8qKlxuICAgKiBNYXhpbXVtIGFjdGl2aXR5IGxldmVsICh6ZXJvIGluZGV4ZWQpLlxuICAgKi9cbiAgbWF4TGV2ZWw/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUb2dnbGUgZm9yIGxvYWRpbmcgc3RhdGUuIGBkYXRhYCBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQgaWYgc2V0LlxuICAgKi9cbiAgbG9hZGluZz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBSZW5kZXIgcHJvcCBmb3IgY2FsZW5kYXIgYmxvY2tzIChhY3Rpdml0aWVzKS4gRm9yIGV4YW1wbGUsIHVzZWZ1bCB0byB3cmFwXG4gICAqIHRoZSBlbGVtZW50IHdpdGggYSB0b29sdGlwIGNvbXBvbmVudC4gVXNlIGBSZWFjdC5jbG9uZUVsZW1lbnRgIHRvIHBhc3NcbiAgICogYWRkaXRpb25hbCBwcm9wcyB0byB0aGUgZWxlbWVudCBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICByZW5kZXJCbG9jaz86IChibG9jazogQmxvY2tFbGVtZW50LCBhY3Rpdml0eTogQWN0aXZpdHkpID0+IFJlYWN0RWxlbWVudDtcbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBzaG93IHdlZWtkYXkgbGFiZWxzIGxlZnQgdG8gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgc2hvd1dlZWtkYXlMYWJlbHM/OiBib29sZWFuO1xuICAvKipcbiAgICogU3R5bGUgb2JqZWN0IHRvIHBhc3MgdG8gY29tcG9uZW50IGNvbnRhaW5lci5cbiAgICovXG4gIHN0eWxlPzogQ1NTUHJvcGVydGllcztcbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsZW5kYXIgY29sb3JzIGZvciB0aGUgbGlnaHQgYW5kIGRhcmsgc3lzdGVtIGNvbG9yIHNjaGVtZS5cbiAgICogRGVmaW5lIGVhY2ggY29sb3Igc2NhbGUgZXhwbGljaXRseSBieSBzZXR0aW5ncyBhbGwgY29sb3JzICg1IHBlciBkZWZhdWx0KVxuICAgKiBvciBwYXNzIGV4YWN0bHkgdHdvIGNvbG9ycyAodGhlIGxvd2VzdCBhbmQgaGlnaGVzdCBpbnRlbnNpdHkpIHRvIGNhbGN1bGF0ZVxuICAgKiBhIHNpbmdsZS1odWUgc2NhbGUuIENvbG9ycyBjYW4gYmUgc3BlY2lmaWVkIGluIGFueSB2YWxpZCBDU1MgZm9ybWF0LlxuICAgKlxuICAgKiBUaGUgY29sb3JzIGZvciBhdCBsZWFzdCBvbmUgc2NoZW1lIG11c3QgYmUgc2V0LiBJZiB1bmRlZmluZWQsIHRoZSBkZWZhdWx0XG4gICAqIHRoZW1lIGlzIHVzZWQuIEJ5IGRlZmF1bHQsIHRoZSBjYWxlbmRhciB3aWxsIHNlbGVjdCB0aGUgY3VycmVudCBzeXN0ZW0gY29sb3JcbiAgICogc2NoZW1lLCBidXQgeW91IGNhbiBlbmZvcmNlIGEgc3BlY2lmaWMgc2NoZW1lIHdpdGggdGhlIGBjb2xvclNjaGVtZWAgcHJvcC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHN4XG4gICAqIDxBY3Rpdml0eUNhbGVuZGFyXG4gICAqICAgZGF0YT17ZGF0YX1cbiAgICogICB0aGVtZT17e1xuICAgKiAgICAgbGlnaHQ6IFsnaHNsKDAsIDAlLCA5MiUpJywgJ2ZpcmVicmljayddLFxuICAgKiAgICAgZGFyazogWycjMzMzJywgJ3JnYigyMTQsIDE2LCAxNzQpJ10sXG4gICAqICAgfX1cbiAgICogLz5cbiAgICogYGBgXG4gICAqXG4gICAqL1xuICB0aGVtZT86IFRoZW1lSW5wdXQ7XG4gIC8qKlxuICAgKiBPdmVyd3JpdGUgdGhlIHRvdGFsIGFjdGl2aXR5IGNvdW50LlxuICAgKi9cbiAgdG90YWxDb3VudD86IG51bWJlcjtcbiAgLyoqXG4gICAqIEluZGV4IG9mIGRheSB0byBiZSB1c2VkIGFzIHN0YXJ0IG9mIHdlZWsuIDAgcmVwcmVzZW50cyBTdW5kYXkuXG4gICAqL1xuICB3ZWVrU3RhcnQ/OiBXZWVrRGF5O1xufVxuXG5jb25zdCBBY3Rpdml0eUNhbGVuZGFyOiBGdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSAoe1xuICBkYXRhLFxuICBibG9ja01hcmdpbiA9IDQsXG4gIGJsb2NrUmFkaXVzID0gMixcbiAgYmxvY2tTaXplID0gMTIsXG4gIGNvbG9yU2NoZW1lID0gdW5kZWZpbmVkLFxuICBldmVudEhhbmRsZXJzID0ge30sXG4gIGZvbnRTaXplID0gMTQsXG4gIGhpZGVDb2xvckxlZ2VuZCA9IGZhbHNlLFxuICBoaWRlTW9udGhMYWJlbHMgPSBmYWxzZSxcbiAgaGlkZVRvdGFsQ291bnQgPSBmYWxzZSxcbiAgbGFiZWxzOiBsYWJlbHNQcm9wID0gdW5kZWZpbmVkLFxuICBtYXhMZXZlbCA9IDQsXG4gIGxvYWRpbmcgPSBmYWxzZSxcbiAgcmVuZGVyQmxvY2sgPSB1bmRlZmluZWQsXG4gIHNob3dXZWVrZGF5TGFiZWxzID0gZmFsc2UsXG4gIHN0eWxlOiBzdHlsZVByb3AgPSB7fSxcbiAgdGhlbWU6IHRoZW1lUHJvcCA9IHVuZGVmaW5lZCxcbiAgdG90YWxDb3VudDogdG90YWxDb3VudFByb3AgPSB1bmRlZmluZWQsXG4gIHdlZWtTdGFydCA9IDAsIC8vIFN1bmRheVxufTogUHJvcHMpID0+IHtcbiAgbWF4TGV2ZWwgPSBNYXRoLm1heCgxLCBtYXhMZXZlbCk7XG5cbiAgY29uc3QgdGhlbWUgPSBjcmVhdGVUaGVtZSh0aGVtZVByb3AsIG1heExldmVsICsgMSk7XG4gIGNvbnN0IHN5c3RlbUNvbG9yU2NoZW1lID0gdXNlQ29sb3JTY2hlbWUoKTtcbiAgY29uc3QgY29sb3JTY2FsZSA9IHRoZW1lW2NvbG9yU2NoZW1lID8/IHN5c3RlbUNvbG9yU2NoZW1lXTtcblxuICBjb25zdCB1c2VBbmltYXRpb24gPSAhdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcblxuICBpZiAobG9hZGluZykge1xuICAgIGRhdGEgPSBnZW5lcmF0ZUVtcHR5RGF0YSgpO1xuICB9XG5cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB5ZWFyID0gZ2V0WWVhcihwYXJzZUlTTyhkYXRhWzBdPy5kYXRlKSk7XG4gIGNvbnN0IHdlZWtzID0gZ3JvdXBCeVdlZWtzKGRhdGEsIHdlZWtTdGFydCk7XG5cbiAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MQUJFTFMsIGxhYmVsc1Byb3ApO1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGhpZGVNb250aExhYmVscyA/IDAgOiBmb250U2l6ZSArIExBQkVMX01BUkdJTjtcblxuICBjb25zdCB3ZWVrZGF5TGFiZWxPZmZzZXQgPSBzaG93V2Vla2RheUxhYmVsc1xuICAgID8gbWF4V2Vla2RheUxhYmVsTGVuZ3RoKHdlZWtzWzBdLCB3ZWVrU3RhcnQsIGxhYmVscy53ZWVrZGF5cywgZm9udFNpemUpICsgTEFCRUxfTUFSR0lOXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdlZWtzLmxlbmd0aCAqIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgLSBibG9ja01hcmdpbixcbiAgICAgIGhlaWdodDogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogNyAtIGJsb2NrTWFyZ2luLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJzKGFjdGl2aXR5OiBBY3Rpdml0eSk6IFNWR1JlY3RFdmVudEhhbmRsZXIge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3Qua2V5cyhldmVudEhhbmRsZXJzKSBhcyBBcnJheTxrZXlvZiBTVkdSZWN0RXZlbnRIYW5kbGVyPlxuICAgICkucmVkdWNlPFNWR1JlY3RFdmVudEhhbmRsZXI+KFxuICAgICAgKGhhbmRsZXJzLCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgICBba2V5XTogKGV2ZW50OiBSZWFjdEV2ZW50PFNWR1JlY3RFbGVtZW50PikgPT4gZXZlbnRIYW5kbGVyc1trZXldPy4oZXZlbnQpKGFjdGl2aXR5KSxcbiAgICAgIH0pLFxuICAgICAge30sXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckNhbGVuZGFyKCkge1xuICAgIHJldHVybiB3ZWVrc1xuICAgICAgLm1hcCgod2Vlaywgd2Vla0luZGV4KSA9PlxuICAgICAgICB3ZWVrLm1hcCgoYWN0aXZpdHksIGRheUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFhY3Rpdml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGl2aXR5LmxldmVsIDwgMCB8fCBhY3Rpdml0eS5sZXZlbCA+IG1heExldmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgYFByb3ZpZGVkIGFjdGl2aXR5IGxldmVsICR7YWN0aXZpdHkubGV2ZWx9IGZvciAke2FjdGl2aXR5LmRhdGV9IGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7bWF4TGV2ZWx9LmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0eWxlID1cbiAgICAgICAgICAgIGxvYWRpbmcgJiYgdXNlQW5pbWF0aW9uXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBgJHtzdHlsZXMubG9hZGluZ0FuaW1hdGlvbn0gMS43NXMgZWFzZS1pbi1vdXQgaW5maW5pdGVgLFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3dlZWtJbmRleCAqIDIwICsgZGF5SW5kZXggKiAyMH1tc2AsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGNvbnN0IGJsb2NrID0gKFxuICAgICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgICAgey4uLmdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHkpfVxuICAgICAgICAgICAgICB4PXswfVxuICAgICAgICAgICAgICB5PXtsYWJlbEhlaWdodCArIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiBkYXlJbmRleH1cbiAgICAgICAgICAgICAgd2lkdGg9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgaGVpZ2h0PXtibG9ja1NpemV9XG4gICAgICAgICAgICAgIHJ4PXtibG9ja1JhZGl1c31cbiAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICBmaWxsPXtjb2xvclNjYWxlW2FjdGl2aXR5LmxldmVsXX1cbiAgICAgICAgICAgICAgZGF0YS1kYXRlPXthY3Rpdml0eS5kYXRlfVxuICAgICAgICAgICAgICBkYXRhLWxldmVsPXthY3Rpdml0eS5sZXZlbH1cbiAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxGcmFnbWVudCBrZXk9e2FjdGl2aXR5LmRhdGV9PlxuICAgICAgICAgICAgICB7cmVuZGVyQmxvY2sgPyByZW5kZXJCbG9jayhibG9jaywgYWN0aXZpdHkpIDogYmxvY2t9XG4gICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgICAgLm1hcCgod2VlaywgeCkgPT4gKFxuICAgICAgICA8ZyBrZXk9e3h9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgkeyhibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiB4fSwgMClgfT5cbiAgICAgICAgICB7d2Vla31cbiAgICAgICAgPC9nPlxuICAgICAgKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJGb290ZXIoKSB7XG4gICAgaWYgKGhpZGVUb3RhbENvdW50ICYmIGhpZGVDb2xvckxlZ2VuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxDb3VudCA9XG4gICAgICB0eXBlb2YgdG90YWxDb3VudFByb3AgPT09ICdudW1iZXInXG4gICAgICAgID8gdG90YWxDb3VudFByb3BcbiAgICAgICAgOiBkYXRhLnJlZHVjZSgoc3VtLCBhY3Rpdml0eSkgPT4gc3VtICsgYWN0aXZpdHkuY291bnQsIDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxmb290ZXJcbiAgICAgICAgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2Zvb3RlcicsIHN0eWxlcy5mb290ZXIpfVxuICAgICAgICBzdHlsZT17eyBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgID5cbiAgICAgICAgey8qIFBsYWNlaG9sZGVyICovfVxuICAgICAgICB7bG9hZGluZyAmJiA8ZGl2PiZuYnNwOzwvZGl2Pn1cblxuICAgICAgICB7IWxvYWRpbmcgJiYgIWhpZGVUb3RhbENvdW50ICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdjb3VudCcpfT5cbiAgICAgICAgICAgIHtsYWJlbHMudG90YWxDb3VudFxuICAgICAgICAgICAgICA/IGxhYmVscy50b3RhbENvdW50XG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgne3tjb3VudH19JywgU3RyaW5nKHRvdGFsQ291bnQpKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7eWVhcn19JywgU3RyaW5nKHllYXIpKVxuICAgICAgICAgICAgICA6IGAke3RvdGFsQ291bnR9IGFjdGl2aXRpZXMgaW4gJHt5ZWFyfWB9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAgeyFsb2FkaW5nICYmICFoaWRlQ29sb3JMZWdlbmQgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2xlZ2VuZC1jb2xvcnMnLCBzdHlsZXMubGVnZW5kQ29sb3JzKX0+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBtYXJnaW5SaWdodDogJzAuNGVtJyB9fT57bGFiZWxzPy5sZWdlbmQ/Lmxlc3MgPz8gJ0xlc3MnfTwvc3Bhbj5cbiAgICAgICAgICAgIHtBcnJheShtYXhMZXZlbCArIDEpXG4gICAgICAgICAgICAgIC5maWxsKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgLm1hcCgoXywgbGV2ZWwpID0+IChcbiAgICAgICAgICAgICAgICA8c3ZnIHdpZHRoPXtibG9ja1NpemV9IGhlaWdodD17YmxvY2tTaXplfSBrZXk9e2xldmVsfT5cbiAgICAgICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPXtibG9ja1NpemV9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17YmxvY2tTaXplfVxuICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvclNjYWxlW2xldmVsXX1cbiAgICAgICAgICAgICAgICAgICAgcng9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgICAgICByeT17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcwLjRlbScgfX0+e2xhYmVscz8ubGVnZW5kPy5tb3JlID8/ICdNb3JlJ308L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Zvb3Rlcj5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzKCkge1xuICAgIGlmICghc2hvd1dlZWtkYXlMYWJlbHMgJiYgaGlkZU1vbnRoTGFiZWxzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge3Nob3dXZWVrZGF5TGFiZWxzICYmIChcbiAgICAgICAgICA8ZyBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnbGVnZW5kLXdlZWtkYXknKX0+XG4gICAgICAgICAgICB7d2Vla3NbMF0ubWFwKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBkYXlJbmRleCA9IChpbmRleCArIHdlZWtTdGFydCkgJSA3O1xuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgICAgIHg9ey1MQUJFTF9NQVJHSU59XG4gICAgICAgICAgICAgICAgICB5PXtsYWJlbEhlaWdodCArIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiBpbmRleCArIGJsb2NrU2l6ZSAvIDJ9XG4gICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJlbmRcIlxuICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7bGFiZWxzLndlZWtkYXlzW2RheUluZGV4XX1cbiAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2c+XG4gICAgICAgICl9XG4gICAgICAgIHshaGlkZU1vbnRoTGFiZWxzICYmIChcbiAgICAgICAgICA8ZyBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnbGVnZW5kLW1vbnRoJyl9PlxuICAgICAgICAgICAge2dldE1vbnRoTGFiZWxzKHdlZWtzLCBsYWJlbHMubW9udGhzKS5tYXAoKHsgbGFiZWwsIHdlZWtJbmRleCB9KSA9PiAoXG4gICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgeD17KGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIHdlZWtJbmRleH1cbiAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiaGFuZ2luZ1wiXG4gICAgICAgICAgICAgICAga2V5PXt3ZWVrSW5kZXh9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKX1cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cblxuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldERpbWVuc2lvbnMoKTtcblxuICBjb25zdCBjb250YWluZXJTdHlsZXMgPSB7XG4gICAgZm9udFNpemUsXG4gICAgLi4uKHVzZUFuaW1hdGlvbiAmJiB7XG4gICAgICBbYC0tJHtOQU1FU1BBQ0V9LWxvYWRpbmdgXTogY29sb3JTY2FsZVswXSxcbiAgICAgIFtgLS0ke05BTUVTUEFDRX0tbG9hZGluZy1hY3RpdmVgXTpcbiAgICAgICAgY29sb3JTY2hlbWUgPT09ICdsaWdodCdcbiAgICAgICAgICA/IGNocm9tYShjb2xvclNjYWxlWzBdKS5kYXJrZW4oMC4zKS5oZXgoKVxuICAgICAgICAgIDogY2hyb21hKGNvbG9yU2NhbGVbMF0pLmJyaWdodGVuKDAuMjUpLmhleCgpLFxuICAgIH0pLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGFydGljbGVcbiAgICAgIGNsYXNzTmFtZT17YCR7TkFNRVNQQUNFfSAke3N0eWxlcy5jb250YWluZXJ9YH1cbiAgICAgIHN0eWxlPXt7IC4uLnN0eWxlUHJvcCwgLi4uY29udGFpbmVyU3R5bGVzIH19XG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnc2Nyb2xsLWNvbnRhaW5lcicsIHN0eWxlcy5zY3JvbGxDb250YWluZXIpfT5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICB2aWV3Qm94PXtgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWB9XG4gICAgICAgICAgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2NhbGVuZGFyJywgc3R5bGVzLmNhbGVuZGFyKX1cbiAgICAgICAgICBzdHlsZT17eyBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHshbG9hZGluZyAmJiByZW5kZXJMYWJlbHMoKX1cbiAgICAgICAgICB7cmVuZGVyQ2FsZW5kYXIoKX1cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICAgIHtyZW5kZXJGb290ZXIoKX1cbiAgICA8L2FydGljbGU+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2tlbGV0b246IEZ1bmN0aW9uQ29tcG9uZW50PE9taXQ8UHJvcHMsICdkYXRhJz4+ID0gcHJvcHMgPT4gKFxuICA8QWN0aXZpdHlDYWxlbmRhciBkYXRhPXtbXX0gey4uLnByb3BzfSAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQWN0aXZpdHlDYWxlbmRhcjtcbiJdLCJuYW1lcyI6WyJOQU1FU1BBQ0UiLCJMQUJFTF9NQVJHSU4iLCJERUZBVUxUX01PTlRIX0xBQkVMUyIsIkRFRkFVTFRfTEFCRUxTIiwibW9udGhzIiwid2Vla2RheXMiLCJ0b3RhbENvdW50IiwibGVnZW5kIiwibGVzcyIsIm1vcmUiLCJ1c2VDb2xvclNjaGVtZSIsImNvbG9yU2NoZW1lIiwic2V0Q29sb3JTY2hlbWUiLCJ1c2VTdGF0ZSIsIm9uQ2hhbmdlIiwiZXZlbnQiLCJtYXRjaGVzIiwidXNlRWZmZWN0IiwibWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInF1ZXJ5IiwidXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJwcmVmZXJzUmVkdWNlZE1vdGlvbiIsInNldFByZWZlcnNSZWR1Y2VkTW90aW9uIiwic3R5bGVJbmplY3QiLCJjc3MiLCJyZWYiLCJpbnNlcnRBdCIsImRvY3VtZW50IiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic3R5bGUiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImZpcnN0Q2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJncm91cEJ5V2Vla3MiLCJhY3Rpdml0aWVzIiwid2Vla1N0YXJ0IiwibGVuZ3RoIiwibm9ybWFsaXplZEFjdGl2aXRpZXMiLCJmaWxsSG9sZXMiLCJmaXJzdERhdGUiLCJwYXJzZUlTTyIsImRhdGUiLCJmaXJzdENhbGVuZGFyRGF0ZSIsImdldERheSIsInN1YldlZWtzIiwibmV4dERheSIsInBhZGRlZEFjdGl2aXRpZXMiLCJBcnJheSIsImRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyIsImZpbGwiLCJ1bmRlZmluZWQiLCJudW1iZXJPZldlZWtzIiwiTWF0aCIsImNlaWwiLCJtYXAiLCJfIiwid2Vla0luZGV4Iiwic2xpY2UiLCJkYXRlTWFwIiwiYWN0aXZpdHkiLCJlYWNoRGF5T2ZJbnRlcnZhbCIsInN0YXJ0IiwiZW5kIiwiZGF5IiwiZm9ybWF0SVNPIiwicmVwcmVzZW50YXRpb24iLCJjb3VudCIsImxldmVsIiwiZ2V0TW9udGhMYWJlbHMiLCJ3ZWVrcyIsIm1vbnRoTmFtZXMiLCJyZWR1Y2UiLCJsYWJlbHMiLCJ3ZWVrIiwiZmlyc3RBY3Rpdml0eSIsImZpbmQiLCJFcnJvciIsIm1vbnRoIiwiZ2V0TW9udGgiLCJwcmV2TGFiZWwiLCJsYWJlbCIsImZpbHRlciIsImluZGV4IiwibWluV2Vla3MiLCJnZXRDbGFzc05hbWUiLCJuYW1lIiwic3R5bGVzIiwiZ2VuZXJhdGVFbXB0eURhdGEiLCJ5ZWFyIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiZGF5cyIsIm1heFdlZWtkYXlMYWJlbExlbmd0aCIsImZpcnN0V2VlayIsImZvbnRTaXplIiwibWF4TGVuZ3RoIiwiZGF5SW5kZXgiLCJjdXJMZW5ndGgiLCJjYWxjVGV4dERpbWVuc2lvbnMiLCJ3aWR0aCIsIm1heCIsInRleHQiLCJSYW5nZUVycm9yIiwiaGVpZ2h0IiwibmFtZXNwYWNlIiwic3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwicG9zaXRpb24iLCJ2aXNpYmlsaXR5IiwiZm9udEZhbWlseSIsImdldENvbXB1dGVkU3R5bGUiLCJib2R5IiwidGV4dE5vZGUiLCJ0ZXh0Q29udGVudCIsImJvdW5kaW5nQm94IiwiZ2V0QkJveCIsInJlbW92ZUNoaWxkIiwiY3JlYXRlVGhlbWUiLCJpbnB1dCIsInNpemUiLCJkZWZhdWx0VGhlbWUiLCJjcmVhdGVEZWZhdWx0VGhlbWUiLCJ2YWxpZGF0ZVRoZW1lIiwibGlnaHQiLCJkYXJrIiwiaXNDb2xvclNjYWxlIiwiY3JlYXRlQ29sb3JTY2FsZSIsImNvbG9ycyIsImludmFsaWRDb2xvciIsImNvbG9yIiwiY2hyb21hIiwidmFsaWQiLCJzY2FsZSIsIm1vZGUiLCJBY3Rpdml0eUNhbGVuZGFyIiwiZGF0YSIsImJsb2NrTWFyZ2luIiwiYmxvY2tSYWRpdXMiLCJibG9ja1NpemUiLCJldmVudEhhbmRsZXJzIiwiaGlkZUNvbG9yTGVnZW5kIiwiaGlkZU1vbnRoTGFiZWxzIiwiaGlkZVRvdGFsQ291bnQiLCJsYWJlbHNQcm9wIiwibWF4TGV2ZWwiLCJsb2FkaW5nIiwicmVuZGVyQmxvY2siLCJzaG93V2Vla2RheUxhYmVscyIsInN0eWxlUHJvcCIsInRoZW1lIiwidGhlbWVQcm9wIiwidG90YWxDb3VudFByb3AiLCJzeXN0ZW1Db2xvclNjaGVtZSIsImNvbG9yU2NhbGUiLCJ1c2VBbmltYXRpb24iLCJnZXRZZWFyIiwiT2JqZWN0IiwiYXNzaWduIiwibGFiZWxIZWlnaHQiLCJ3ZWVrZGF5TGFiZWxPZmZzZXQiLCJnZXREaW1lbnNpb25zIiwiZ2V0RXZlbnRIYW5kbGVycyIsImtleXMiLCJoYW5kbGVycyIsImtleSIsInJlbmRlckNhbGVuZGFyIiwiYW5pbWF0aW9uIiwibG9hZGluZ0FuaW1hdGlvbiIsImFuaW1hdGlvbkRlbGF5IiwiYmxvY2siLCJSZWFjdCIsIl9leHRlbmRzIiwieCIsInkiLCJyeCIsInJ5IiwiRnJhZ21lbnQiLCJ0cmFuc2Zvcm0iLCJyZW5kZXJGb290ZXIiLCJzdW0iLCJjbGFzc05hbWUiLCJmb290ZXIiLCJtYXJnaW5MZWZ0IiwicmVwbGFjZSIsIlN0cmluZyIsImxlZ2VuZENvbG9ycyIsIm1hcmdpblJpZ2h0IiwicmVuZGVyTGFiZWxzIiwiZG9taW5hbnRCYXNlbGluZSIsInRleHRBbmNob3IiLCJjb250YWluZXJTdHlsZXMiLCJkYXJrZW4iLCJoZXgiLCJicmlnaHRlbiIsImNvbnRhaW5lciIsInNjcm9sbENvbnRhaW5lciIsInZpZXdCb3giLCJjYWxlbmRhciIsIlNrZWxldG9uIiwicHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;